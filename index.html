<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Fprintf :)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body align="center" style="color: white; background-image: linear-gradient(to right, #0f1625, #180c19);">
		<h1><br>
			&nbsp;
		</h1>
<h2 style="padding: 0px; margin: 0px">TL;DR</h4>
<pre>.....................</pre>

<div class="Section1" style="margin: 40px;">
        <h4><span style="FONT-FAMILY:'Courier New'"><font size="4">The <font face="Times New Roman">fprintf</font>
                                function</font></span></h4>
                                <pre>......</pre>
        <h4><span style="FONT-FAMILY:'Courier New'">Synopsis</span></h4>
        <pre style="MARGIN-LEFT:0.5in">#include &lt;stdio.h&gt;</pre>
        <pre style="MARGIN-LEFT:0.5in">int fprintf(FILE * restrict stream,</pre>
        <pre style="MARGIN-LEFT:0.5in">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, ...);</pre>
        <h4><span style="FONT-FAMILY:'Courier New'">Description</span></h4>
        The fprintf&nbsp; function&nbsp; writes&nbsp; output&nbsp; to&nbsp; the&nbsp; 
        stream pointed to by stream, under control of the string pointed to by&nbsp; 
        format&nbsp; that&nbsp; specifies&nbsp; how&nbsp; subsequent&nbsp; 
        arguments&nbsp; are converted&nbsp; for&nbsp; output.&nbsp; If there are 
        insufficient arguments for the format, the behavior is undefined.&nbsp; If the 
        format is exhausted while arguments remain, the excess arguments are evaluated 
        (as always) but are otherwise ignored. The fprintf function returns when the 
        end of the format string is encountered.
        <p class="MsoNormal">&nbsp;</p>
</div>


<hr style="margin-left: 60px; margin-right: 36px;">
                </h1><p>&nbsp;</p><h1> Programming languages - C</h1></pre>
		<pre>..................................................

</pre>
		<pre><h4>7.13.6.1  The fprintf function</h4>

       <h4>Synopsis</h4>

       [#1]

               #include &lt;stdio.h&gt;
               int fprintf(FILE * restrict stream,
                       const char * restrict format, ...);

       <h4>Description</h4>

       [#2] The  fprintf  function  writes  output  to  the  stream
       pointed to by stream, under control of the string pointed to
       by  format  that  specifies  how  subsequent  arguments  are
       converted  for  output.  If there are insufficient arguments
       for the format, the behavior is undefined.  If the format is
       exhausted  while  arguments remain, the excess arguments are
       evaluated  (as  always)  but  are  otherwise  ignored.   The
       fprintf  function  returns when the end of the format string
       is encountered.

       [#3] The format shall be  a  multibyte  character  sequence,
       beginning and ending in its initial shift state.  The format
       is composed of zero or more directives:  ordinary  multibyte
       characters (not %), which are copied unchanged to the output
       stream; and conversion specifications, each of which results
       in   fetching  zero  or  more  subsequent  arguments.   Each
       conversion specification is introduced by the  character  %.
       After the %, the following appear in sequence:

          - Zero or more flags  (in  any  order)  that  modify  the
            meaning of the conversion specification.

          - An optional minimum  field  width.   If  the  converted
            value  has  fewer  characters  than the field width, it
            will be padded with spaces (by default) on the left (or
            right,  if  the  left adjustment flag, described later,
            has been given) to the field width.   The  field  width
            takes  the form of an asterisk * (described later) or a
            decimal integer.206

          - An optional precision that gives the minimum number  of
            digits  to  appear  for  the  d,  i,  o,  u,  x,  and X
            conversions, the number of digits to appear  after  the
            decimal-point  character  for  a,  A,  e,  E,  f, and F
            conversions, the maximum number of  significant  digits
            for  the  g and G conversions, or the maximum number of
            characters  to  be  written  from   a   string   in   s
            conversions.   The precision takes the form of a period
            (.) followed either by an asterisk * (described  later)
            or  by  an optional decimal integer; if only the period
            is specified, the precision is taken  as  zero.   If  a
            precision  appears with any other conversion specifier,
            the behavior is undefined.

          - An optional hh specifying that a following d, i, o,  u,
            x,  or  X conversion specifier applies to a signed char
            or unsigned char argument (the argument will have  been
            promoted  according  to the integer promotions, and its
            value shall be converted to  signed  char  or  unsigned
            char  before printing); an optional h specifying that a
            following d, i, o, u,  x,  or  X  conversion  specifier
            applies  to  a short int or unsigned short int argument
            (the argument will have been promoted according to  the
            integer promotions, and its value shall be converted to
            short int or unsigned short int  before  printing);  an
            optional  h  specifying  that  a following n conversion
            specifier applies to a pointer to a short int argument;
            an  optional  l (ell) specifying that a following d, i,
            o, u, x, or X conversion specifier applies  to  a  long
            int  or  unsigned  long  int  argument;  an optional ll
            (ell-ell) specifying that a following d, i, o, u, x, or
            X  conversion  specifier  applies to a long long int or
            unsigned  long  long  int  argument;  an   optional   l
            specifying that  a  following  n  conversion  specifier
            applies  to  a  pointer  to  a  long  int  argument; an
            optional ll specifying that a  following  n  conversion
            specifier  applies  to  a  pointer  to  a long long int
            argument; an optional l specifying that a  following  c
            conversion  specifier  applies to a wint_t argument; an
            optional l specifying that  a  following  s  conversion
            specifier  applies  to a pointer to a wchar_t argument;
            an optional l which has no effect on a following a,  A,
            e,  E,  f,  F,  g,  or  G  conversion  specifier; or an
            optional L specifying that a following a, A, e,  E,  f,
            F,  g,  or  G  conversion  specifier  applies to a long
            double argument.  If an hh, h, l, ll, or L appears with
            any   other   conversion  specifier,  the  behavior  is
            undefined.

          - A character that specifies the type of conversion to be
            applied.

       [#4] As noted above, a field width, or precision,  or  both,
       may  be  indicated  by  an  asterisk.   In this case, an int
       argument  supplies  the  field  width  or  precision.    The
       arguments  specifying  field  width,  or precision, or both,
       shall appear (in that order) before the argument (if any) to
       be converted.  A negative field width argument is taken as a
       - flag followed by  a  positive  field  width.   A  negative
       precision  argument  is  taken  as  if  the  precision  were
       omitted.

       [#5] The flag characters and their meanings are

       -     The result of the conversion  will  be  left-justified
             within the field.  (It will be right-justified if this
             flag is not specified.)

       +     The result of a signed conversion  will  always  begin
             with a plus or minus sign.  (It will begin with a sign
             only when a negative value is converted if  this  flag
             is not specified.)207

       space If the first character of a signed conversion is not a
             sign,   or  if  a  signed  conversion  results  in  no
             characters, a space will be prefixed  to  the  result.

             If the space and + flags both appear, the  space  flag
             will be ignored.

       #     The result  is  to  be  converted  to  an  ``alternate
             form.''  For o conversion, it increases the precision,
             if and only if necessary, to force the first digit  of
             the  result  to  be a zero (if the value and precision
             are both 0, a single 0 is  printed).   For  x  (or  X)
             conversion,  a  nonzero  result  will  have 0x (or 0X)
             prefixed to it.  For a, A,  e,  E,  f,  F,  g,  and  G
             conversions,   the   result   will  always  contain  a
             decimal-point character, even if no digits follow  it.
             (Normally,  a  decimal-point  character appears in the
             result of these conversions only if  a  digit  follows
             it.)   For g and G conversions, trailing zeros are not
             removed from the result.  For other  conversions,  the
             behavior is undefined.

       0     For d, i, o, u, x, X, a, A, e,  E,  f,  F,  g,  and  G
             conversions,  leading  zeros (following any indication
             of sign or base) are used to pad to the  field  width;
             no  space  padding is performed.  If the 0 and - flags
             both appear, the 0 flag will be ignored.  For d, i, o,
             u,  x, and X conversions, if a precision is specified,
             the 0 flag will be ignored.   For  other  conversions,
             the behavior is undefined.

       [#6] The conversion specifiers and their meanings are

       d,i     The int argument is converted to signed  decimal  in
               the  style  [ - ]dddd.   The precision specifies the
               minimum number of digits to  appear;  if  the  value
               being  converted can be represented in fewer digits,
               it will be expanded with leading zeros.  The default
               precision  is  1.   The  result of converting a zero
               value with a precision of zero is no characters.

       o,u,x,X The unsigned int argument is converted  to  unsigned
               octal   (o),   unsigned  decimal  (u),  or  unsigned
               hexadecimal notation (x or X) in the style dddd; the
               letters  abcdef  are  used  for x conversion and the
               letters ABCDEF  for  X  conversion.   The  precision
               specifies the minimum number of digits to appear; if
               the value being  converted  can  be  represented  in
               fewer  digits,  it  will  be  expanded  with leading
               zeros.  The default precision is 1.  The  result  of
               converting  a zero value with a precision of zero is
               no characters.

       f,F     A  double  argument  representing  a  floating-point
               number is converted to decimal notation in the style
               [-]ddd.ddd, where the number  of  digits  after  the
               decimal-point  character  is  equal to the precision
               specification.  If the precision is missing,  it  is
               taken  as 6; if the precision is zero and the # flag
               is  not  specified,   no   decimal-point   character
               appears.   If  a decimal-point character appears, at
               least one digit appears before  it.   The  value  is
               rounded to the appropriate number of digits.

               A  double  argument  representing  an  infinity   is
               converted to one of the styles [-]inf or [-]infinity
               - which style is implementation-defined.   A  double
               argument  representing  a NaN is converted in one of
               the styles [-]nan or [-]nan(n-char-sequence) - which
               style,  and  the  meaning of any n-char-sequence, is
               implementation-defined.  The F conversion  specifier
               produces  INF,  INFINITY,  or  NAN  instead  of inf,
               infinity, or nan, respectively.208

       e,E     A  double  argument  representing  a  floating-point
               number is converted in the style [-]d.ddde_dd, where
               there  is  one  digit   before   the   decimal-point
               character  (which  is  nonzero  if  the  argument is
               nonzero) and the number of digits after it is  equal
               to the precision; if the precision is missing, it is
               taken as 6; if the precision is zero and the #  flag
               is   not   specified,   no  decimal-point  character
               appears.  The value is rounded  to  the  appropriate
               number  of  digits.  The E conversion specifier will
               produce a number with E instead of e introducing the
               exponent.  The exponent always contains at least two
               digits, and only as many more digits as necessary to
               represent  the  exponent.  If the value is zero, the
               exponent is zero.

               A double argument representing an infinity or a  NaN
               is  converted  in  the style of an f or F conversion
               specifier.

       g,G     A  double  argument  representing  a  floating-point
               number  is  converted in style f or e (or in style F
               or E in the case of a G conversion specifier),  with
               the  precision  specifying the number of significant
               digits.  If the precision is zero, it is taken as 1.
               The style used depends on the value converted; style
               e (or E) will be used only if the exponent resulting
               from  such  a  conversion is less than -4 or greater
               than or equal to the precision.  Trailing zeros  are
               removed from the fractional portion of the result; a
               decimal-point  character  appears  only  if  it   is
               followed by a digit.  A double argument representing
               an infinity or NaN is converted in the style of an f
               or F conversion specifier.

       a,A     A  double  argument  representing  a  floating-point
               number  is  converted  in  the style [-]0xh.hhhhp_d.
               The  number  of  hexadecimal  digits  h  after   the
               decimal-point  character  is equal to the precision;
               if the precision is missing and FLT_RADIX is a power
               of  2, then the precision is sufficient for an exact
               representation of the value;  if  the  precision  is
               missing  and FLT_RADIX is not a power of 2, then the
               precision is sufficient to distinguish209  values of
               type  double,  except  that  trailing  zeros  may be
               omitted.  The hexadecimal digit to the left  of  the
               decimal-point  character  is  nonzero for normalized
               floating-point    numbers    and    is     otherwise
               unspecified;210  if the precision is zero and the  #
               flag  is  not  specified, no decimal-point character
               appears.   The  letters  abcdef  are  used   for   a
               conversion  and the letters ABCDEF for A conversion.
               The a conversion specifier  will  produce  a  number
               with  x  and  p  and the A conversion specifier will
               produce a number with X and P.  The exponent  always
               contains  at  least one digit, and only as many more
               digits  as  necessary  to  represent   the   decimal
               exponent  of  2.  If the value is zero, the exponent
               is zero.  A double argument representing an infinity
               or  a  NaN  is  converted  in the style of an f or F
               conversion specifier.

       c       If no l qualifier is present, the  int  argument  is
               converted  to  an  unsigned  char, and the resulting
               character  is  written.    Otherwise,   the   wint_t
               argument  is  converted  as  if  by an ls conversion
               specification with no precision and an argument that
               points to the initial element of a two-element array
               of wchar_t, the first element containing the  wint_t
               argument  to the lc conversion specification and the
               second a null wide character.

       s       If no l qualifier is present, the argument shall  be
               a  pointer  to  the  initial  element of an array of
               character type.211 Characters  from  the  array  are
               written up to (but not including) a terminating null
               character. If the precision is  specified,  no  more
               than  that  many  characters  are  written.  If  the
               precision is not specified or is  greater  than  the
               size  of  the  array, the array shall contain a null
               character.

               If an l qualifier is present, the argument shall  be
               a  pointer  to  the  initial  element of an array of
               wchar_t type.  Wide characters from  the  array  are
               converted  to  multibyte characters (each as if by a
               call to the wcrtomb function,  with  the  conversion
               state  described  by an mbstate_t object initialized
               to  zero  before  the  first   wide   character   is
               converted)  up  to  and including a terminating null
               wide character. The resulting  multibyte  characters
               are   written   up   to   (but  not  including)  the
               terminating null character (byte). If  no  precision
               is  specified,  the  array shall contain a null wide
               character. If a precision is specified, no more than
               that  many characters (bytes) are written (including
               shift  sequences,  if  any),  and  the  array  shall
               contain  a  null  wide  character  if,  to equal the
               multibyte character sequence  length  given  by  the
               precision,  the function would need to access a wide
               character one past the end of the array. In no  case
               is a partial multibyte character written.212

       p       The argument shall be a pointer to void.  The  value
               of  the  pointer  is  converted  to  a  sequence  of
               printable characters, in  an  implementation-defined
               manner.

       n       The argument shall be a pointer  to  signed  integer
               into  which  is  written  the  number  of characters
               written to the output stream so far by this call  to
               fprintf.   No  argument  is  converted,  but  one is
               consumed. If the conversion specification with  this
               conversion  specifier  is  not one of %n, %ln, %lln,
               %hn, or %hhn, the behavior is undefined.

       %       A % is written.   No  argument  is  converted.   The
               complete conversion specification shall be %%.

       [#7] If a conversion specification is invalid, the  behavior
       is undefined.213

       [#8] If any argument  is,  or  points  to,  a  union  or  an
       aggregate  (except  for  an  array  of  char  type  using %s
       conversion, an array of wchar_t type using  %ls  conversion,
       or   a   pointer  using  %p  conversion),  the  behavior  is
       undefined.

       [#9] In no case does a  nonexistent  or  small  field  width
       cause  truncation  of a field; if the result of a conversion
       is wider than the field width,  the  field  is  expanded  to
       contain the conversion result.

       [#10] For a and A conversions, if FLT_RADIX is a power of 2,
       the  value  is  correctly

       rounded to  a  hexadecimal  floating  number  with  the  given
       precision. Recommended practice [#11] If FLT_RADIX is not a power of
       2,  the  result  is  one  of  the  two
       adjacent  numbers  in  hexadecimal floating style with the
       given precision, with the extra stipulation that  the error have a
       correct  sign  for the current rounding direction. [#12]
       For  e,  E,  f,  F,  g,  and   G
       conversions,  if  the number of significant decimal digits is at
       most DECIMAL_DIG,

       then the result is correctly  rounded.214  If  the  number
       of significant decimal digits is more than DECIMAL_DIG  but the
       source value is exactly representable with DECIMAL_DIG  digits,  then
       the result is an exact representation with trailing zeros. Otherwise,
       the source value is bounded by two adjacent
       decimal   strings  L  &lt;  U,  both  having   DECIMAL_DIG
       significant digits; the value of the  resultant  decimal
       string D satisfies L &lt; D &lt; U, with the extra stipulation that <br>       the error have a  correct  sign for the current rounding direction.
</pre>
		<pre>       <h4>Returns</h4>

       [#13] The fprintf function returns the number of  characters
       transmitted,   or  a  negative  value  if  an  output  error
       occurred.

       Environmental limit

       [#14] The minimum value for the maximum number of characters
       produced by any single conversion shall be 4095.

       <h4>Examples</h4>

       [#15] To print a date and time in the form ``Sunday, July 3,
       10:02'' followed by pi to five decimal places:

               #include &lt;math.h&gt;
               #include &lt;stdio.h&gt;
               /* ... */
               char *weekday, *month;    // pointers to strings
               int day, hour, min;
               fprintf(stdout, "%s, %s %d, %.2d:%.2d\n",
                       weekday, month, day, hour, min);
               fprintf(stdout, "pi = %.5f\n", 4 * atan(<a href="http://www.vmunix.com/~gabor/c/draft.html#1.0">1.0</a>));

       [#16] In this example, multibyte characters do  not  have  a
       state-dependent  encoding,  and the multibyte members of the
       extended character set each consist of two bytes, the  first<br>       of which is denoted here by  a  $0  and  the  second  by  an
       uppercase letter.

       [#17] Given the following wide string with length seven,

               static wchar_t wstr[] = L"$0X$0Yabc$0Z$0W";

       [#18] the seven calls

               fprintf(stdout, "|1234567890123|\n");
               fprintf(stdout, "|%13ls|\n", wstr);
               fprintf(stdout, "|%-13.9ls|\n", wstr);
               fprintf(stdout, "|%13.10ls|\n", wstr);
               fprintf(stdout, "|%13.1ls|\n", wstr);
               fprintf(stdout, "|%13.15ls|\n", &amp;wstr[2]);
               fprintf(stdout, "|%13lc|\n", wstr[5]);

       [#19] will print the following seven lines:

               |1234567890123|
               |  $0X$0Yabc$0Z$0W|
               |$0X$0Yabc$0Z    |
               |    $0X$0Yabc$0Z|
               |  $0X$0Yabc$0Z$0W|
               |      abc$0Z$0W|
               |           $0Z|

 <br><br>	____________________________________________________________ <br>	207. The results of all floating conversions of a negative zero, <br>	     and of negative values that round to zero, include a minus sign. <br>	208. When applied to infinite and NaN values, the -, +, and space<br>	     flag characters have their usual meaning; the # and 0 flag <br>	     characters have no effect. 206. Note that 0 is taken as a flag,<br>	     not as the beginning of a field width. <br>	209. The precision p is sufficient to distinguish values of the source <br>	     type if 16p-1 &gt; bn where b is FLT_RADIX and n is the number of <br>	     base-b digits in the significand of the source type. A smaller <br>	     p might suffice depending on the implementation's scheme for <br>	     determining the digit to the left of the decimal- point character. <br>	210. Binary implementations can choose the hexadecimal digit to the <br>	     left of the decimal-point character so that subsequent digits <br>	     align to nibble (4-bit) boundaries. <br>	211. No special provisions are made for multibyte characters. <br>	212. Redundant shift sequences may result if multibyte characters <br>	     have a state-dependent encoding. <br>	213. See ``future library directions''. <br>	214. For binary-to-decimal conversion, the result format's values <br>	     are the numbers representable with the given format specifier. <br>	     The number of significant digits is determined by the format <br>	     specifier, and in the case of fixed-point conversion by the <br>	     source value as well. 

</body>



</html>